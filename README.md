
# Some sort of security?

Проблем и видов атак которые злоумышленики могут доставить и совершить различное множество. Здесь я попробую кратко объяснить чего вам стоит избегать в своих проектах, и привнести в проект, хоть какую никакую безопасность.

## python eval()
За кулисами Python 2 оценивает ввод и выполняет его с помощью eval (). Это позволяет использовать гибкий код, но потенциально опасно. В приведенном ниже примере пользователь может импортировать модуль Python и выполнить команду для удаления файла.

```python
eval("import('os').system('rm sample.txt')")
```

Опять же, использование raw_input с Python 2 или ввода с Python 3 будет анализировать входные данные и дезинфицировать их.

Непосредственное использование eval () также сопряжено с опасностями по причинам, изложенным выше. К счастью, у него есть необязательные аргументы, чтобы ограничить выполнение функции eval().

```python
eval(expression[, globals[, locals]])
```

Установка второго аргумента в {"\_\_builtins__":} запретит eval() доступ к любым встроенным методам Python, и вы можете использовать третий аргумент для установки локальных функций и переменных, к которым eval() разрешен доступ. Это подход к тому, чтобы сделать eval() более безопасным, но он требует большой работы по выведению списка запретов, и что-то всегда может проскользнуть через сеть.

Для дальнейшего ознакомления с данной темой, прошу вас прочитать статью [Ned Batchedlder](https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html)
## SQL Injection
Представьте данную функцию, которая проверяет являеться ли username администратором.
```python
def is_admin(username: str) -> bool:
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT
                admin
            FROM
                users
            WHERE
                username = '%s'
        """ % username)
        result = cursor.fetchone()

    if result is None:
        # User does not exist
        return False

    admin, = result
    return admin
```

```python
>>> is_admin('haki')
False
>>> is_admin('ran')
True
>>> is_admin('foo')
False
```
Но погодите
```python
>>> is_admin("'; select true; --")
True
```

Давайте еще раз посмотрим на реализацию. Распечатайте фактический запрос, выполняемый в базе данных:
```python
>>> print("select admin from users where username = '%s'" % "'; select true; --")
select admin from users where username = ''; select true; --'
```
Полученный текст содержит три утверждения. Чтобы точно понять, как работает Python SQL-инъекция, вам необходимо проверить каждую часть индивидуально. Первое утверждение выглядит следующим образом:  

```sql
select admin from users where username = '';
```

Это ваш предполагаемый запрос. Точка с запятой (;) завершает запрос, поэтому результат этого запроса не имеет значения. Далее идет второе утверждение:  
```sql
select true;
```

Эта выборка была построена злоумышленником. Она разработана так, чтобы всегда возвращать значение True.

Наконец, вы видите этот короткий фрагмент кода:
```sql
--'
```

Этот фрагмент обезвреживает все, что следует за ним. Злоумышленник добавил символ комментария (-), чтобы превратить все, что вы могли поставить после последнего заполнителя, в комментарий.

Когда вы выполняете функцию с этим аргументом, она всегда возвращает True. Если, например, вы используете эту функцию на своей странице входа в систему, злоумышленник может войти в систему с именем пользователя  '; select true; --', и ему будет предоставлен доступ.

Если вы думаете, что это плохо, может быть и хуже! Злоумышленники, знающие структуру вашей таблицы, могут использовать Python SQL-инъекцию, чтобы нанести непоправимый ущерб. Например, злоумышленник может ввести оператор обновления, чтобы изменить информацию в базе данных:

```python
>>> is_admin('haki')
False
>>> is_admin("'; update users set admin = 'true' where username = 'haki'; select true; --")
True
>>> is_admin('haki')
True
```

Разберем команду по новой.

```sql
';
```
Этот фрагмент завершает запрос, как и в предыдущей инъекции. Следующее утверждение выглядит следующим образом:
```sql
update users set admin = 'true' where username = 'haki';
```
Этот раздел обновляет admin до true для пользователя haki.
Наконец, вот этот фрагмент кода:
```sql
select true; --
```

Как и в предыдущем примере, эта часть возвращает True и комментирует все, что следует за ней.

Чем хуже? Что ж, если злоумышленнику удастся выполнить функцию с этим вводом, то пользователь haki станет админом:

``` database
psycopgtest=# select * from users;
 username | admin
----------+-------
 ran      | t
 haki     | t
(2 rows)
```

### Создание безопасных параметров запроса  
В предыдущем разделе вы увидели, как злоумышленник может использовать вашу систему и получить права администратора, используя тщательно созданную строку. Проблема заключалась в том, что вы разрешили выполнение значения, переданного от клиента, непосредственно в базу данных без выполнения какой-либо проверки или проверки. SQL-инъекции основаны на уязвимостях этого типа.

Каждый раз, когда пользовательский ввод используется в запросе к базе данных, существует возможная уязвимость для SQL-инъекции. Ключ к предотвращению внедрения Python SQL - убедиться, что значение используется так, как задумал разработчик. В предыдущем примере вы намеревались использовать имя пользователя как строку. На самом деле он использовался как необработанный оператор SQL.

Чтобы убедиться, что значения используются по назначению, вам нужно экранировать значение. Например, чтобы злоумышленники не вводили необработанный SQL вместо строкового аргумента, вы можете избегать кавычек:

```python
>>> # Плохой пример. Не используйте!
>>> username = username.replace("'", "''")
```

К счастью для вас, современные адаптеры баз данных поставляются со встроенными инструментами для предотвращения внедрения Python SQL с помощью параметров запроса. Они используются вместо простой строковой интерполяции для составления запроса с параметрами.

Теперь, когда вы лучше понимаете уязвимость, вы готовы переписать функцию, используя параметры запроса вместо интерполяции строк:

```python
def is_admin(username: str) -> bool:
    with connection.cursor() as cursor:
        cursor.execute("""
            SELECT
                admin
            FROM
                users
            WHERE
                username = %(username)s
        """, {
            'username': username
        })
        result = cursor.fetchone()

    if result is None:
        # User does not exist
        return False

    admin, = result
    return admin
```

Вот что отличается в этом примере:

В строке 9 вы использовали имя пользователя с именованным параметром, чтобы указать, куда должно идти имя пользователя. Обратите внимание, что имя пользователя параметра больше не заключено в одинарные кавычки.

В строке 11 вы передали значение username в качестве второго аргумента функции cursor.execute (). Соединение будет использовать тип и значение имени пользователя при выполнении запроса в базе данных.

### Передача параметров безопасного запроса  
Адаптеры баз данных обычно предлагают несколько способов передачи параметров запроса. Именованные заполнители обычно лучше всего подходят для чтения, но некоторые реализации могут выиграть от использования других параметров.

Давайте быстро рассмотрим некоторые из правильных и неправильных способов использования параметров запроса. В следующем блоке кода показаны типы запросов, которых следует избегать:


```python
# Плохие примеры. Не используйте!
cursor.execute("SELECT admin FROM users WHERE username = '" + username + '");
cursor.execute("SELECT admin FROM users WHERE username = '%s' % username);
cursor.execute("SELECT admin FROM users WHERE username = '{}'".format(username));
cursor.execute(f"SELECT admin FROM users WHERE username = '{username}'");
```

Каждый из этих операторов передает имя пользователя от клиента непосредственно в базу данных без выполнения какой-либо проверки или проверки. Такой код созрел для того, чтобы предложить Python SQL-инъекцию.

Напротив, эти типы запросов должны быть безопасными для выполнения:

```python
# Безопасные примеры. Используйте их!
cursor.execute("SELECT admin FROM users WHERE username = %s'", (username, ));
cursor.execute("SELECT admin FROM users WHERE username = %(username)s", {'username': username});
```
В этих операторах имя пользователя передается как именованный параметр. Теперь база данных будет использовать указанный тип и значение имени пользователя при выполнении запроса, предлагая защиту от внедрения Python SQL.

## Regular Expressions (RegEx)
Если вы столкнулись с проблемой, которая решается при помощи регулярных выражений - то теперь у вас две проблемы.

### Значение
> Регуля́рные выраже́ния (англ. regular expressions) — используемый в компьютерных программах, работающих с текстом, формальный язык поиска и осуществления манипуляций с подстроками в тексте, основанный на использовании метасимволов (символов-джокеров, англ. wildcard characters). Для поиска используется строка-образец (англ. pattern, по-русски её часто называют «шаблоном», «маской»), состоящая из символов и метасимволов и задающая правило поиска. Для манипуляций с текстом дополнительно задаётся строка замены, которая также может содержать в себе специальные символы.
  Source: Wikipedia.



### Базовые Спецсимволы
| Спецсимволы |  Обозначение                |
| :-------- |  :------------------------- |
| `^` |  Начало строки.  |
| `$` |  Конец строки.  |
| `.` |  Любой символ кроме переводов строки (без параметра /.../s).    |
| `[ ... ]` |  Любой из перечисленного набора символов. |
| `[^ ... ]` |  Ни один из перечисленного набора символов.  |
| `\s` |  Пробел (tab/space/cr/lf).  |
| `\S` |  Не пробел.  |
| `\w` |  Символ слова (буквы, цифры, _).  |
| `\W` |  Символ не-слова. |
| `\d` |  Число.  |
| `\D` |  Не число.  |
| `\u` |  Символ в верхнем регистре.  |
| `\l` |  В нижнем.  |

### Базовые Операторы
| Операторы |  Обозначение                |
| :-------- |  :------------------------- |
|  `( ... )` | Сгруппировать символы в один паттерн и запомнить |
| \| |Предыдущий или следующий паттерн (логическое "ИЛИ") |
| * |	Ноль или больше раз |
|+|	Один или больше раз |
|?|	0 или 1 раз предыдущая маска |
|{n}|	Повторять n раз |
|{n,}|	Повторять n или больше раз |
|{n,m} |	Повторять от n до m раз |


### Примеры использования Регулярок

`.` - Период. Соответствует любому одиночному символу, кроме символа новой строки.

```python
>>> re.search(r'Co.k.e', 'Cookie').group()
'Cookie'
```

`^` - Каретка. Соответствует началу строки.
```python
>>> re.search(r'^Eat', "Eat cake!").group()
'Eat'
```

`$` - Соответствует концу строки.
```python
>>> re.search(r'cake$', "Cake! Let's eat cake").group()
'cake'
```

Для ознакомления с остальнымы операторами, пройдите по [данной ссылке](https://www.datacamp.com/community/tutorials/python-regular-expression-tutorial?utm_source=adwords_ppc&utm_campaignid=1455363063&utm_adgroupid=65083631748&utm_device=c&utm_keyword=&utm_matchtype=b&utm_network=g&utm_adpostion=&utm_creative=278443377086&utm_targetid=aud-392016246653:dsa-473406579035&utm_loc_interest_ms=&utm_loc_physical_ms=1009827&gclid=CjwKCAjwrPCGBhALEiwAUl9X05oFAl4o1Zxu6WLst1Up_YSbNblf7kZiFLM7xnXAMCV0kwXJwwZO5RoCIXkQAvD_BwE) на детальное описание каждого из спецсимволов и операторов. 

### re lib
Для работы с регулярками в Python вам придеться использовать библиотеку re  
```python
import re 
```  
Давайте, разберем основные её методы с которыми вы чаще всего будете сталкиваться.

* __re.match()__

Функция `re.match()` для re в Python будет искать шаблон регулярного выражения и возвращать первое вхождение.  
Метод Python RegEx Match проверяет совпадение только в начале строки.   
Итак, если совпадение найдено в первой строке, он возвращает объект совпадения.  
Но если совпадение найдено в какой-либо другой строке, функция Python RegEx Match возвращает значение null.  


* __re.search()__

Функция `re.search()` будет искать шаблон регулярного выражения и возвращать первое вхождение.  
В отличие от Python `re.match()`, он проверяет все строки входной строки.    
Функция Python `re.search()` возвращает объект соответствия, когда шаблон найден, и «null», если шаблон не найден.  

* __re.findall()__

Модуль `re.findall()` используется для поиска «всех» вхождений, соответствующих заданному шаблону.  
Напротив, модуль `re.search()` вернет только первое вхождение, соответствующее указанному шаблону.  
`re.findall()` выполнит итерацию по всем строкам файла и вернет все неперекрывающиеся совпадения шаблона за один шаг.

### Ресурсы
* Шикарнейшая статья про регулярки на хабре - [тут!](https://habr.com/ru/post/349860/)  
* Поупражняться с регулярками можно на сайте [regex101.com](https://regex101.com/r/F8dY80/3)
* Визуализировать регулярки поможет [debuggex.com](https://www.debuggex.com/)
